package eu.optimis.elasticityengine.callback;

import eu.optimis.elasticityengine.ElasticityCallback;

/**
 * Prints the callback methods generated by elasticity instead of forwarding
 * them to anyone. Also have a signalling functionality for use in tests, a
 * thread calling "awaitRecommendation" will wait in here until the specific
 * recommendation is sent to the printed, which can be used to signal that the
 * testrun is complete.
 * 
 * @author Daniel Espling (<a href="mailto:espling@cs.umu.se">espling@cs.umu.se</a>)
 *Copyright (C) 2012 Ume√• University

* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.

* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 */
public class CallbackPrinter implements ElasticityCallback {

	int currentNr = 1;
	int counter=0;
	private int signalNr;
	private Object testLock = new Object();
	private String name="Fake";

	public void receiveRecommendation(String serviceID, String vmTypeID,
			int nrOfVMs) {
		System.out.println("Java: got callback: serviceID: " + serviceID
				+ " vmTypeID: " + vmTypeID + " nrOfVMs: " + nrOfVMs);
	}
	@Override
	public String Fake(){
		return name;
	}

	@Override
	public void addVM(String serviceID, String serviceManifest, String imageID,
			int num, String spAddress) {
		currentNr += num;
		System.out.println("ADDING " + num + " instance(s) to " + serviceID + '/' + imageID + " using spAddress: " + spAddress+ " Current Nr.:"+currentNr);
		
	}

	@Override
	public void removeVM(String serviceID, String imageID, int num, String spAddress) {
		currentNr -= num;
		System.out.println("REMOVING " + num + " instance(s) from " + serviceID + '/' + imageID + " using spAddress: " + spAddress+ " Current Nr.:"+currentNr);

		

		if (currentNr == signalNr) {
			counter++;
			System.out.println(counter+" "+ currentNr+" "+ signalNr);
		}
		if(counter==1){
			synchronized (testLock) {
				testLock.notifyAll();
			}
		}
	}

	@Override
	public String getNrInstances(String serviceID, String imageID) {
		return currentNr + ""; // XXX bit ugly
	}


	public void awaitLoad(int i) {
		this.signalNr = i;

		try {
			synchronized (testLock) {
				testLock.wait();
			}
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
